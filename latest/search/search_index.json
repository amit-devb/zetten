{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Introduction","text":""},{"location":"#introduction_1","title":"Introduction","text":"<p>Zetten is a high-performance, deterministic execution engine for Python backend projects. Built in Rust, it acts as a focused task runner designed to unify how you run tests, linters, and builds.</p> <p>Zetten ensures that your workflow remains identical across local development environments and any CI platform\u2014only faster.</p>"},{"location":"#the-mental-model","title":"The Mental Model","text":"<p>Think of Zetten as an execution engine, not a framework. Unlike tools that rely on implicit behavior, Zetten requires explicit declarations:</p> <ul> <li>Tasks are explicit: You define exactly what to run.</li> <li>Inputs are declared: You tell Zetten which files matter.</li> <li>Execution is deterministic: The same configuration behaves the same everywhere.</li> <li>Results are cached: If inputs haven't changed, the task is skipped.</li> <li>Output is CI-safe: Logs and exit codes are designed for automation.</li> </ul> <p>Get Started</p>"},{"location":"#performance","title":"\ud83c\udfce\ufe0f Performance","text":"<p>Zetten is built for speed. Benchmarks against popular task runners show it provides the fastest developer experience for incremental builds.</p> Metric Tool Time vs Zetten Startup <code>ztn</code> 2.08 ms 1.00x (CLI overhead) <code>just</code> 2.15 ms 1.04x <code>make</code> 3.85 ms 1.85x <code>poe</code> 41.88 ms 20.15x Smart Caching <code>ztn</code> 3.49 ms 1.00x (No-op re-run) <code>just</code> 4.26 ms 1.22x <code>make</code> 5.63 ms 1.61x <code>poe</code> 64.68 ms 18.52x <p>&gt; Benchmarks run on macOS (Apple Silicon).</p>"},{"location":"#what-zetten-is-not","title":"What Zetten Is Not","text":"<p>To understand Zetten, it is helpful to know what it is not: - It is not a framework or a workflow engine. - It is not a plugin system or a background service. - It is not a runtime dependency of your application.</p> <p>It is a small, fast, and predictable execution tool accessed via the <code>ztn</code> command.</p>"},{"location":"ai_context/","title":"Zetten Context for AI Agents","text":"<p>Role: You are an AI Assistant helping a developer work on this project. Tool: The project uses <code>zetten</code> (binary: <code>ztn</code>) as its primary task runner.</p>"},{"location":"ai_context/#what-is-zetten","title":"\u26a1 What is Zetten?","text":"<p>Zetten is a language-agnostic task runner that executes commands defined in <code>pyproject.toml</code> (or <code>zetten.toml</code>). It handles: - Dependency Management: Tasks run in the correct order (DAG). - Parallelism: Independent tasks run concurrently. - Caching: Tasks are skipped if their inputs haven't changed.</p>"},{"location":"ai_context/#how-to-run-tasks","title":"\ud83d\udee0 How to Run Tasks","text":"<p>Do NOT run raw commands like <code>pytest</code>, <code>ruff</code>, or <code>python main.py</code> directly unless initialized. Instead, ask Zetten to run them.</p>"},{"location":"ai_context/#1-discovery","title":"1. Discovery","text":"<p>First, list the available tasks to understand the project's capabilities:</p> <pre><code>ztn tasks\n</code></pre>"},{"location":"ai_context/#2-execution","title":"2. Execution","text":"<p>Run a specific task:</p> <pre><code>ztn run &lt;task_name&gt;\n</code></pre> <p>Run multiple tasks (Zetten optimizes the order):</p> <pre><code>ztn run lint test build\n</code></pre>"},{"location":"ai_context/#3-debugging","title":"3. Debugging","text":"<p>If a task fails, Zetten provides a specific error code. - If you see <code>ztn::config::missing</code>, suggest running <code>ztn init</code>. - If you see <code>ztn::graph::cycle</code>, check <code>depends_on</code> in the config. - Use <code>ztn doctor</code> to check for environment issues.</p>"},{"location":"ai_context/#ai-skills-common-patterns","title":"\ud83e\udde0 AI \"Skills\" / Common Patterns","text":""},{"location":"ai_context/#1-the-safe-change-pattern","title":"1. The \"Safe Change\" Pattern","text":"<p>When asked to refactor or fix code: 1. Run <code>ztn run lint</code> before starting to ensure a clean state. 2. Make your changes. 3. Run <code>ztn run test</code> to verify.</p>"},{"location":"ai_context/#2-the-ci-simulation-pattern","title":"2. The \"CI Simulation\" Pattern","text":"<p>To guarantee your changes will pass CI:</p> <pre><code>ztn run --tag ci\n</code></pre> <p>This runs the exact subset of tasks defined for the CI pipeline.</p>"},{"location":"ai_context/#3-dependency-analysis","title":"3. Dependency Analysis","text":"<p>If you are unsure why a task is running (or not running), inspect the graph:</p> <pre><code>ztn run &lt;task&gt; --dry-run\n</code></pre> <p>Example:</p> <pre><code>[tool.zetten.tasks.test]\ncmd = \"pytest\"\ninputs = [\"tests/\", \"src/\"]  # Cache invalidation key\ndepends_on = [\"setup\"]       # Dependency\ntags = [\"ci\"]                # Grouping\n</code></pre> <p>Variables: Zetten resolves variables in this order: 1. CLI: <code>ztn run task -k KEY=val</code> 2. Config: <code>[tool.zetten.vars]</code> 3. Environment: <code>os.environ</code></p> <p>When modifying the project, prefer adding new tasks to <code>pyproject.toml</code> rather than creating shell scripts.</p>"},{"location":"benchmarks/","title":"Benchmarks","text":"<p>We believe in transparency. Benchmarks are often biased, so we provide the exact methodology and scripts used to produce these numbers. You can run them yourself using the code in the <code>benchmarks/</code> directory of this repository.</p>"},{"location":"benchmarks/#summary-results","title":"\ud83d\udcca Summary Results","text":"Metric Zetten Just Make PoeThePoet Startup Time 2.08 ms 2.15 ms 3.85 ms 41.88 ms No-Op (Cached) 3.49 ms 4.26 ms 5.63 ms 64.68 ms Cold Build 60 ms* 4 ms 6 ms 66 ms Binary Size 2.9 MB 3.6 MB 0.1 MB N/A (Python) Peak Memory ~9 MB ~9 MB ~9 MB ~27 MB <p>&gt; Note on Cold Build: Zetten performs content-hashing on all input files even during a cold build to populate the cache. Tools like <code>make</code> and <code>just</code> do not check content hashes by default, explaining their speed advantage in this specific \"blind run\" scenario.</p>"},{"location":"benchmarks/#methodology","title":"\ud83d\udd2c Methodology","text":"<p>Our benchmarks are automated using <code>hyperfine</code>, a command-line benchmarking tool.</p>"},{"location":"benchmarks/#environment","title":"Environment","text":"<ul> <li>Hardware: Apple Silicon (M1 Pro) / Ubuntu Latest (CI)</li> <li>Tool Versions: Latest stable releases as of Feb 2026.</li> <li>Python: 3.10+</li> </ul>"},{"location":"benchmarks/#tools-used","title":"Tools Used","text":"<ol> <li>Hyperfine: For statistical precision (warmup runs, outlier detection).</li> <li>Time: For measuring peak memory (RSS).</li> <li>wc/du: For binary size analysis.</li> </ol>"},{"location":"benchmarks/#scenarios","title":"Scenarios","text":""},{"location":"benchmarks/#1-startup-time-version","title":"1. Startup Time (<code>--version</code>)","text":"<p>Measures the overhead of the CLI itself. - Command: <code>tool --version</code> - Why it matters: Developer experience. Laggy CLIs break flow state.</p>"},{"location":"benchmarks/#2-no-op-cached-build","title":"2. No-Op (Cached Build)","text":"<p>Measures the time to determine \"nothing needs to be done\". - Command: <code>tool run build</code> (where sources are unchanged) - Why it matters: 90% of developer builds are incremental. Zetten uses content hashing; others often use file modification timestamps (mtime).</p>"},{"location":"benchmarks/#3-cold-build","title":"3. Cold Build","text":"<p>Measures a fresh build from scratch. - Command: <code>tool run build</code> (after <code>clean</code>) - Why it matters: CI/CD pipelines often start fresh.</p>"},{"location":"benchmarks/#run-the-benchmarks-yourself","title":"\ud83c\udfc3 Run the Benchmarks Yourself","text":"<p>Clone the repository and run the included runner:</p> <pre><code># 1. Install dependencies\npip install hyperfine\n\n# 2. Run the benchmark suite\npython3 benchmarks/runner.py --scenario all\n</code></pre>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#installation_1","title":"Installation","text":"<p>Zetten is distributed as a single, self-contained binary written in Rust, but it is easily installable via common Python package managers.</p>"},{"location":"installation/#install-with-pip","title":"Install with pip","text":"<p>The easiest way to install Zetten is via <code>pip</code>:</p> <pre><code>pip install zetten\n</code></pre>"},{"location":"installation/#install-with-uv","title":"Install with uv","text":"<pre><code>uv add zetten\n</code></pre>"},{"location":"installation/#install-with-poetry","title":"Install with poetry","text":"<pre><code>poetry add zetten\n</code></pre>"},{"location":"installation/#verify-installation","title":"Verify Installation","text":"<p>Once installed, verify that the binary is available in your PATH:</p> <pre><code>ztn --help\n</code></pre>"},{"location":"installation/#requirements","title":"Requirements","text":"<ul> <li>Python-Aware: Zetten detects Python environments automatically but does not depend on a specific Python version to run.</li> <li>No Virtual Env Required: You do not need to activate a virtual environment to use the <code>ztn</code> binary itself (though your tasks might run commands inside one).</li> <li>OS Support: Native support for Linux, macOS, and Windows.</li> </ul>"},{"location":"quickstart/","title":"Quickstart","text":""},{"location":"quickstart/#quickstart_1","title":"Quickstart","text":"<p>Getting started with Zetten takes less than a minute.</p>"},{"location":"quickstart/#1-configure-a-task","title":"1. Configure a Task","text":"<p>Open your <code>pyproject.toml</code> and add a task (e.g., for your linter):</p> <pre><code>[tool.zetten.tasks.lint]\ncmd = \"ruff check src\"\ninputs = [\"src/\"]\n</code></pre>"},{"location":"quickstart/#2-run-the-task","title":"2. Run the Task","text":"<p>Execute the task using the <code>run</code> command:</p> <pre><code>ztn run lint\n</code></pre>"},{"location":"features/caching/","title":"Smart Caching","text":"<p>Zetten uses content-addressable hashing to ensure you never run the same code twice.</p>"},{"location":"features/caching/#how-hashes-are-calculated","title":"How Hashes are Calculated","text":"<p>Task results are cached based on: - The Command: Any change to the <code>cmd</code> string invalidates the cache. - Input Files: A byte-by-byte check of all declared files and directories. - Dependencies: If a parent task changes, all dependent tasks are re-evaluated.</p>"},{"location":"features/caching/#explicit-reporting","title":"Explicit Reporting","text":"<p>Zetten never hides what it's doing. Cached tasks are always reported explicitly in the terminal output so you know exactly which results are fresh and which are reused.</p>"},{"location":"features/dependencies/","title":"Enhanced Dependency Management","text":"<p>Zetten provides robust hooks for managing task lifecycles, ensuring your environment is always in a known state.</p>"},{"location":"features/dependencies/#setup-teardown","title":"Setup &amp; Teardown","text":"<p>You can define <code>setup</code> and <code>teardown</code> tasks for any task.</p> <pre><code>[tasks.db_test]\ncmd = \"pytest tests/db\"\nsetup = \"db_init\"\nteardown = \"db_clean\"\n</code></pre>"},{"location":"features/dependencies/#behavior","title":"Behavior","text":"<ol> <li>Setup (<code>db_init</code>): Runs before <code>db_test</code>. If <code>setup</code> fails, <code>db_test</code> is skipped.</li> <li>Main Task (<code>db_test</code>): Runs only if <code>setup</code> succeeds.</li> <li>Teardown (<code>db_clean</code>): Runs after <code>db_test</code> completes, regardless of success or failure.</li> </ol> <p>This is crucial for cleanup tasks like dropping test databases or removing temporary files.</p>"},{"location":"features/dependencies/#dag-dependencies","title":"DAG Dependencies","text":"<p>Standard dependencies still apply via <code>depends_on</code>:</p> <pre><code>[tasks.test]\ndepends_on = [\"lint\", \"build\"]\n</code></pre> <p>Zetten guarantees <code>lint</code> and <code>build</code> finish successfully before <code>test</code> starts.</p>"},{"location":"features/determinism/","title":"Determinism","text":"<p>Zetten is deterministic by design. We believe that a task runner should never \"guess\" what you want it to do.</p>"},{"location":"features/determinism/#stability-across-environments","title":"Stability Across Environments","text":"<p>The same configuration behaves exactly the same way: - Locally on your machine. - Inside a Docker container. - Across different CI providers (GitHub Actions, GitLab, Jenkins).</p>"},{"location":"features/determinism/#no-implicit-behavior","title":"No Implicit Behavior","text":"<p>There is no environment-based guessing. Zetten only knows what you tell it in the configuration files. - The same inputs produce the same task hash. - The same task graph executes in the same order.</p>"},{"location":"features/execution/","title":"Execution Model","text":"<p>Zetten utilizes a high-performance worker pool to maximize your hardware's potential.</p>"},{"location":"features/execution/#parallel-execution","title":"Parallel Execution","text":"<p>Zetten builds a Directed Acyclic Graph (DAG) of your tasks.  - Independent tasks (e.g., Linting and Type Checking) run in parallel across available CPU cores. - Dependent tasks (e.g., Testing) wait until their requirements are satisfied.</p>"},{"location":"features/execution/#dependency-detection","title":"Dependency Detection","text":"<p>If Zetten detects a cycle in your dependencies (e.g., Task A depends on B, and B depends on A), it will fail immediately with a clear error message rather than entering an infinite loop.</p>"},{"location":"features/scripts/","title":"Python Script Execution","text":"<p>Zetten allows you to run Python functions directly, bypassing the need for separate shell scripts or <code>python -m</code> commands.</p>"},{"location":"features/scripts/#configuration","title":"Configuration","text":"<p>Use the <code>script</code> key in your <code>[tasks]</code> definition.</p> <pre><code>[tasks.hello]\ndescription = \"Run a greeting function\"\nscript = \"my_module:greet\"\n</code></pre> <p>This is equivalent to running:</p> <pre><code>python -c \"import my_module; my_module.greet()\"\n</code></pre>"},{"location":"features/scripts/#inline-modules","title":"Inline Modules","text":"<p>You can also run modules directly:</p> <pre><code>[tasks.server]\nscript = \"http.server\"\n</code></pre> <p>Equivalent to: <code>python -m http.server</code></p>"},{"location":"features/scripts/#why-use-script-over-cmd","title":"Why use <code>script</code> over <code>cmd</code>?","text":"<ol> <li>Cross-Platform: no need to worry about <code>/</code> vs <code>\\</code> or shell differences.</li> <li>Performance: slightly faster startup as it avoids shell process overhead.</li> <li>Cleanliness: keeps your config focused on Python logic.</li> </ol>"},{"location":"features/tags/","title":"Advanced Tagging","text":"<p>Tags allow you to filter which tasks to run. Zetten supports boolean logic for powerful selection.</p>"},{"location":"features/tags/#defining-tags","title":"Defining Tags","text":"<pre><code>[tasks.lint]\ntags = [\"ci\", \"fast\"]\n\n[tasks.test_unit]\ntags = [\"ci\", \"fast\"]\n\n[tasks.test_e2e]\ntags = [\"ci\", \"slow\"]\n</code></pre>"},{"location":"features/tags/#filtering-via-cli","title":"Filtering via CLI","text":"<p>Use the <code>--tag</code> (or <code>-t</code>) flag.</p>"},{"location":"features/tags/#basic-selection","title":"Basic Selection","text":"<p>Run all tasks with the <code>ci</code> tag:</p> <pre><code>ztn run --tag ci\n</code></pre>"},{"location":"features/tags/#and-logic","title":"AND Logic (<code>+</code>)","text":"<p>Run tasks that have BOTH <code>ci</code> and <code>fast</code>:</p> <pre><code>ztn run --tag \"ci+fast\"\n</code></pre>"},{"location":"features/tags/#not-logic","title":"NOT Logic (<code>!</code>)","text":"<p>Run tasks that have <code>ci</code> but NOT <code>slow</code>:</p> <pre><code>ztn run --tag \"ci+!slow\"\n</code></pre>"},{"location":"features/tags/#or-logic-comma","title":"OR Logic (Comma)","text":"<p>Run tasks that match <code>fast</code> OR <code>slow</code>:</p> <pre><code>ztn run --tag \"fast,slow\"\n</code></pre>"},{"location":"features/tags/#complex-combinations","title":"Complex Combinations","text":"<p>Run (CI and Fast) OR (Manual):</p> <pre><code>ztn run --tag \"ci+fast,manual\"\n</code></pre>"},{"location":"guides/ci/","title":"CI Usage","text":"<p>Zetten is designed for the modern CI/CD pipeline. By using Tags and Strict Mode, you can ensure your pipeline is both flexible and safe.</p>"},{"location":"guides/ci/#add-a-tag-to-a-task","title":"Add a tag to a task","text":"<pre><code>[tool.zetten.tasks.lint]\ncmd = \"ruff check src\"\ninputs = [\"src/\"]\ntags = [\"ci\"]\n</code></pre>"},{"location":"guides/ci/#run-the-task-in-ci","title":"Run the task in CI","text":"<pre><code>ztn run --tag ci\n</code></pre>"},{"location":"guides/ci/#force-a-specific-version-and-environment-in-ci","title":"Force a specific version and environment in CI","text":"<pre><code>ztn run --tag ci -k VERSION=${GITHUB_SHA} -k ENV=prod\n</code></pre> <p>If a foundational task fails, Zetten halts downstream execution immediately to save CI minutes and prevent cascading failures.</p>"},{"location":"guides/ci/#practical-example-cicd","title":"Practical Example: CI/CD","text":"<p>In a GitHub Action, you might want to pass the commit SHA into your build task:</p> <ul> <li>Config: <code>cmd = \"echo Building version ${VERSION:-dev}\"</code></li> <li>Local Run: <code>ztn run build \u2192 Output: \"Building version dev\"</code></li> <li>CI Run: <code>ztn run build -k VERSION=${{ github.sha }} \u2192 Output: \"Building version a1b2c3d...</code></li> </ul>"},{"location":"guides/config/","title":"Configuration","text":"<p>Configuration in Zetten is explicit by design. There is no templating and no conditionals.</p>"},{"location":"guides/config/#supported-files","title":"Supported Files","text":""},{"location":"guides/config/#pyprojecttoml-preferred","title":"<code>pyproject.toml</code> (Preferred)","text":"<pre><code>[tool.zetten.tasks.test]\ncmd = \"pytest\"\ninputs = [\"src/\", \"tests/\"]\n</code></pre>"},{"location":"guides/config/#zettentoml-option","title":"<code>zetten.toml</code> (Option)","text":"<pre><code>[tasks.test]\ncmd = \"pytest\"\ninputs = [\"src/\", \"tests/\"]\n</code></pre>"},{"location":"guides/config/#resolution-rules","title":"Resolution Rules","text":"<p>Zetten follows a strict logic to find your settings. If the configuration is missing or ambiguous, Zetten will fail with an explanation rather than trying to guess.</p> <ul> <li>Check pyproject.toml: If it exists and contains a [tool.zetten] header, Zetten uses it.</li> <li>Check zetten.toml: If pyproject.toml doesn't have Zetten settings, it looks for this file.</li> <li>Initialization: If neither is found, the project is considered uninitialized.</li> </ul> <p>To fix a missing configuration, run:</p> <pre><code>ztn init\n</code></pre>"},{"location":"guides/config/#example-defining-a-task","title":"Example: Defining a Task","text":"<p>A task consists of three main parts: - <code>cmd</code>: The actual shell command to run (e.g., pytest or ruff). - <code>inputs</code>: A list of files or directories Zetten should \"watch.\" If these don't change, Zetten skips the run. - <code>depends_on</code> (Optional): Other tasks that must finish before this one starts. - <code>tags</code> (Optional): Optional labels to group tasks (e.g., <code>[\"ci\"]</code>). - <code>description</code> (Optional): Optional field to describe a task - <code>hints</code> (Options): A field to help developer set some hints when the user encouters any issues.</p> <p>Full Example in pyproject.toml:</p> <pre><code>[tool.zetten.tasks.lint]\ncmd = \"ruff check src\"\ninputs = [\"src/\"]\n\n[tool.zetten.tasks.test]\ncmd = \"pytest\"\ninputs = [\"src/\", \"tests/\"]\ndepends_on = [\"lint\"]\n</code></pre>"},{"location":"guides/config/#pro-tip-debugging-variables","title":"Pro-Tip: Debugging Variables","text":"<p>If you aren't sure what value a variable is taking, use the Doctor command:</p> <pre><code>ztn doctor\n</code></pre>"},{"location":"guides/variables/","title":"Variable Hints &amp; Interpolation","text":"<p>Zetten features a powerful, deterministic variable system. It allows you to write one command that adapts to different environments without changing the configuration file.</p>"},{"location":"guides/variables/#syntax","title":"Syntax","text":"<p>In your cmd strings, you can reference variables using the standard shell-like syntax: - ${VAR}: Resolves to the value of VAR. - ${VAR:-default}: Resolves to VAR, or uses default if VAR is not set.</p> <p>Example in <code>pyproject.toml</code>:</p> <pre><code>[tool.zetten.tasks.build]\n# If DEST is not provided, it defaults to 'dist'\ncmd = \"python -m build --outdir ${DEST:-dist}\"\ninputs = [\"src/\"]\n</code></pre>"},{"location":"guides/variables/#the-hierarchy-resolution-order","title":"The Hierarchy (Resolution Order)","text":"<p>Zetten resolves variables using a \"Strict Tier\" system. If a variable is defined in multiple places, the higher tier always wins.</p>"},{"location":"guides/variables/#tier-1-cli-overrides-highest","title":"Tier 1: CLI Overrides (Highest):","text":"<p>Values passed directly via the -k (or --key) flag. This is used for \"one-off\" changes.</p> <pre><code>ztn run build -k DEST=build_output\n</code></pre>"},{"location":"guides/variables/#tier-2-config-file","title":"Tier 2: Config File","text":"<p>Values defined globally in your configuration file under the vars table.</p> <pre><code>[tool.zetten.vars]\nDEST = \"local_cache\"\n</code></pre>"},{"location":"guides/variables/#tier-3-environment-variables-lowest","title":"Tier 3: Environment Variables (Lowest)","text":"<p>Standard system environment variables (e.g., $USER, $PATH, or variables exported in your shell).</p> <pre><code>export DEST=system_dist\nztn run build\n</code></pre>"},{"location":"guides/variables/#global-variables-vars","title":"Global Variables (vars)","text":"<p>Zetten allows you to define a global vars table. These variables act as \"Defaults\"\u2014they will be injected into any task's cmd that references them, unless you override them via the CLI.</p>"},{"location":"guides/variables/#example-pyprojecttoml","title":"Example: <code>pyproject.toml</code>","text":"<p>Place your global variables under the <code>[tool.zetten.vars]</code> section.</p> <pre><code>[tool.zetten.vars]\nBUILD_DIR = \"dist\"\nPYTHON_BIN = \"python3\"\nLOG_LEVEL = \"info\"\n\n[tool.zetten.tasks.build]\n# Uses the global BUILD_DIR and PYTHON_BIN defined above\ncmd = \"${PYTHON_BIN} -m build --outdir ${BUILD_DIR}\"\ninputs = [\"src/\"]\n</code></pre>"},{"location":"guides/variables/#example-zettentoml","title":"Example: <code>zetten.toml</code>","text":"<p>If using a standalone file, use the [vars] header.</p> <pre><code>[vars]\nBUILD_DIR = \"dist\"\n\n[tasks.build]\ncmd = \"mkdir -p ${BUILD_DIR} &amp;&amp; tar -cvf ${BUILD_DIR}/pkg.tar src/\"\ninputs = [\"src/\"]\n</code></pre>"},{"location":"reference/commands/","title":"CLI Commands","text":"<p>The primary binary is <code>ztn</code>.</p>"},{"location":"reference/commands/#ztn-run","title":"<code>ztn run</code>","text":"<p>Execute tasks.</p> <pre><code>ztn run [TASKS]... [FLAGS]\n</code></pre>"},{"location":"reference/commands/#flags","title":"Flags","text":"<ul> <li><code>-w, --workers &lt;NUM&gt;</code>: Set number of parallel workers (default: auto).</li> <li><code>--dry-run</code>: Show execution plan without running commands.</li> <li><code>-t, --tag &lt;EXPR&gt;</code>: Filter tasks by tag expression (e.g., <code>ci+!slow</code>).</li> <li><code>-k, --key-value &lt;KEY&gt;=&lt;VAL&gt;</code>: Override a configuration variable.</li> </ul>"},{"location":"reference/commands/#ztn-watch","title":"<code>ztn watch</code>","text":"<p>Watch for file changes and re-run tasks.</p> <pre><code>ztn watch [TASKS]...\n</code></pre>"},{"location":"reference/commands/#ztn-init","title":"<code>ztn init</code>","text":"<p>Initialize a new project with an interactive template selector.</p>"},{"location":"reference/commands/#ztn-doctor","title":"<code>ztn doctor</code>","text":"<p>Check environment health (Rust, Python, Config).</p>"},{"location":"reference/commands/#ztn-completions","title":"<code>ztn completions</code>","text":"<p>Generate shell completion scripts</p> <pre><code>ztn completions &lt;SHELL&gt;\n</code></pre>"}]}