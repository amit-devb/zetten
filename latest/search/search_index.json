{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Introduction","text":"<p>Zetten is a high-performance, deterministic task runner for Python backend projects. Built in Rust, it acts as a focused execution engine designed to unify how you run tests, linters, and builds.</p> <p>Zetten ensures that your workflow remains identical across local development environments and any CI platform\u2014only faster.</p>"},{"location":"#the-mental-model","title":"The Mental Model","text":"<p>Think of Zetten as an execution engine, not a framework. Unlike tools that rely on implicit behavior, Zetten requires explicit declarations:</p> <ul> <li>Tasks are explicit: You define exactly what to run.</li> <li>Inputs are declared: You tell Zetten which files matter.</li> <li>Execution is deterministic: The same configuration behaves the same everywhere.</li> <li>Results are cached: If inputs haven't changed, the task is skipped.</li> <li>Output is CI-safe: Logs and exit codes are designed for automation.</li> </ul> <p>Get Started{ .md-button .md-button--primary }</p>"},{"location":"#what-zetten-is-not","title":"What Zetten Is Not","text":"<p>To understand Zetten, it is helpful to know what it is not: * It is not a framework or a workflow engine. * It is not a plugin system or a background service. * It is not a runtime dependency of your application.</p> <p>It is a small, fast, and predictable execution tool.</p>"},{"location":"installation/","title":"Installation","text":"<p>Zetten is distributed as a single, self-contained binary. While it is built in Rust, it is easily installable via common Python package managers.</p>"},{"location":"installation/#install-with-pip","title":"Install with pip","text":"<p>The easiest way to install Zetten is via <code>pip</code> or <code>uv</code> or <code>poetry</code>:</p> <pre><code>pip install zetten\n</code></pre>"},{"location":"installation/#install-with-uv","title":"Install with UV","text":"<pre><code>uv add zetten\n</code></pre>"},{"location":"installation/#install-with-poetry","title":"Install with poetry","text":"<pre><code>poetry add zetten\n</code></pre>"},{"location":"installation/#verify-installation","title":"Verify Installation","text":"<p>Once installed, verify that the binary is available in your PATH:</p> <pre><code>zetten --help:\n</code></pre>"},{"location":"installation/#requirements","title":"Requirements","text":"<ul> <li>Python-Aware: Zetten is aware of Python environments but does not depend on a specific Python version to run.</li> <li>No Virtual Env Required: You do not need to activate a virtual environment to use the zetten binary itself.</li> <li>OS Support: Native support for Linux, macOS, and Windows.</li> </ul>"},{"location":"quickstart/","title":"Quickstart","text":"<p>Getting started with Zetten takes less than a minute.</p>"},{"location":"quickstart/#1-initialize-your-project","title":"1. Initialize your project","text":"<p>Run the following command in your project root to create a base configuration:</p> <pre><code>zetten init\n</code></pre>"},{"location":"quickstart/#2-define-your-first-task","title":"2. Define your first task","text":"<p>Open your pyproject.toml and add a task for your linter:</p> <pre><code>[tool.zetten.tasks.lint]\ncmd = \"ruff check src\"\ninputs = [\"src/\"]\n</code></pre>"},{"location":"quickstart/#3-run-the-task","title":"3 Run the task","text":"<p>Execute the task using the run command:</p> <pre><code>zetten run lint\n</code></pre>"},{"location":"features/caching/","title":"Smart Caching","text":"<p>Zetten uses content-addressable hashing to ensure you never run the same code twice.</p>"},{"location":"features/caching/#how-hashes-are-calculated","title":"How Hashes are Calculated","text":"<p>Task results are cached based on: 1. The Command: Any change to the <code>cmd</code> string invalidates the cache. 2. Input Files: A byte-by-byte check of all declared files and directories. 3. Dependencies: If a parent task changes, all dependent tasks are re-evaluated.</p>"},{"location":"features/caching/#explicit-reporting","title":"Explicit Reporting","text":"<p>Zetten never hides what it's doing. Cached tasks are always reported explicitly in the terminal output so you know exactly which results are fresh and which are reused.</p>"},{"location":"features/determinism/","title":"Determinism","text":"<p>Zetten is deterministic by design. We believe that a task runner should never \"guess\" what you want it to do.</p>"},{"location":"features/determinism/#stability-across-environments","title":"Stability Across Environments","text":"<p>The same configuration behaves exactly the same way: * Locally on your machine. * Inside a Docker container. * Across different CI providers (GitHub Actions, GitLab, Jenkins).</p>"},{"location":"features/determinism/#no-implicit-behavior","title":"No Implicit Behavior","text":"<p>There is no environment-based guessing. Zetten only knows what you tell it in the configuration files. * The same inputs produce the same task hash. * The same task graph executes in the same order.</p>"},{"location":"features/execution/","title":"Execution Model","text":"<p>Zetten utilizes a high-performance worker pool to maximize your hardware's potential.</p>"},{"location":"features/execution/#parallel-execution","title":"Parallel Execution","text":"<p>Zetten builds a Directed Acyclic Graph (DAG) of your tasks.  * Independent tasks (e.g., Linting and Type Checking) run in parallel across available CPU cores. * Dependent tasks (e.g., Testing) wait until their requirements are satisfied.</p>"},{"location":"features/execution/#dependency-detection","title":"Dependency Detection","text":"<p>If Zetten detects a cycle in your dependencies (e.g., Task A depends on B, and B depends on A), it will fail immediately with a clear error message rather than entering an infinite loop.</p>"},{"location":"guides/ci/","title":"CI Usage","text":"<p>Zetten is designed for the modern CI/CD pipeline. By using Tags and Strict Mode, you can ensure your pipeline is both flexible and safe.</p>"},{"location":"guides/ci/#we-just-have-to-add-tag-to-a-task","title":"We just have to add tag to a task","text":"<pre><code>[tool.zetten.tasks.lint]\ncmd = \"ruff check src\"\ninputs = [\"src/\"]\n</code></pre>"},{"location":"guides/ci/#run-the-the-task-in-ci","title":"Run the the task in CI","text":"<pre><code>zetten run --tag ci\n</code></pre>"},{"location":"guides/ci/#force-a-specific-version-and-environment-in-ci","title":"Force a specific version and environment in CI","text":"<pre><code>zetten run --tag ci -k VERSION=${GITHUB_SHA} -k ENV=prod\n</code></pre> <p>If a foundational task fails, Zetten halts downstream execution immediately to save CI minutes and prevent cascading failures.</p>"},{"location":"guides/ci/#practical-example-cicd","title":"Practical Example: CI/CD","text":"<p>In a GitHub Action, you might want to pass the commit SHA into your build task: - Config: <code>cmd = \"echo Building version ${VERSION:-dev}\"</code> - Local Run: <code>zetten run build \u2192 Output: \"Building version dev\"</code> - CI Run: <code>zetten run build -k VERSION=${{ github.sha }} \u2192 Output: \"Building version a1b2c3d...</code></p>"},{"location":"guides/config/","title":"Configuration","text":"<p>Configuration in Zetten is explicit by design. There is no templating and no conditionals.</p>"},{"location":"guides/config/#supported-files","title":"Supported Files","text":""},{"location":"guides/config/#pyprojecttoml-preferred","title":"<code>pyproject.toml</code> (Preferred)","text":"<pre><code>[tool.zetten.tasks.test]\ncmd = \"pytest\"\ninputs = [\"src/\", \"tests/\"]\n</code></pre>"},{"location":"guides/config/#zettentoml-option","title":"<code>zetten.toml</code> (Option)","text":"<pre><code>[tasks.test]\ncmd = \"pytest\"\ninputs = [\"src/\", \"tests/\"]\n</code></pre>"},{"location":"guides/config/#resolution-rules","title":"Resolution Rules","text":"<p>Zetten follows a strict logic to find your settings. If the configuration is missing or ambiguous, Zetten will fail with an explanation rather than trying to guess.</p> <ul> <li>Check pyproject.toml: If it exists and contains a [tool.zetten] header, Zetten uses it.</li> <li>Check zetten.toml: If pyproject.toml doesn't have Zetten settings, it looks for this file.</li> <li>Initialization: If neither is found, the project is considered uninitialized.</li> </ul> <p>To fix a missing configuration, run:</p> <pre><code>zetten init\n</code></pre>"},{"location":"guides/config/#example-defining-a-task","title":"Example: Defining a Task","text":"<p>A task consists of three main parts: - <code>cmd</code>: The actual shell command to run (e.g., pytest or ruff). - <code>inputs</code>: A list of files or directories Zetten should \"watch.\" If these don't change, Zetten skips the run. - <code>depends_on</code> (Optional): Other tasks that must finish before this one starts. - <code>tags</code> (Optional): Optional labels to group tasks (e.g., <code>[\"ci\"]</code>). - <code>description</code> (Optional): Optional field to describe a task - <code>hints</code> (Options): A field to help developer set some hints when the user encouters any issues.</p> <p>Full Example in pyproject.toml:</p> <pre><code>[tool.zetten.tasks.lint]\ncmd = \"ruff check src\"\ninputs = [\"src/\"]\n\n[tool.zetten.tasks.test]\ncmd = \"pytest\"\ninputs = [\"src/\", \"tests/\"]\ndepends_on = [\"lint\"]\n</code></pre>"},{"location":"guides/config/#pro-tip-debugging-variables","title":"Pro-Tip: Debugging Variables","text":"<p>If you aren't sure what value a variable is taking, use the Doctor command:</p> <pre><code>zetten doctor\n</code></pre>"},{"location":"guides/variables/","title":"Variable Hints &amp; Interpolation","text":"<p>Zetten features a powerful, deterministic variable system. It allows you to write one command that adapts to different environments without changing the configuration file.</p>"},{"location":"guides/variables/#syntax","title":"Syntax","text":"<p>In your cmd strings, you can reference variables using the standard shell-like syntax: - ${VAR}: Resolves to the value of VAR. - ${VAR:-default}: Resolves to VAR, or uses default if VAR is not set.</p> <p>Example in <code>pyproject.toml</code>:</p> <pre><code>[tool.zetten.tasks.build]\n# If DEST is not provided, it defaults to 'dist'\ncmd = \"python -m build --outdir ${DEST:-dist}\"\ninputs = [\"src/\"]\n</code></pre>"},{"location":"guides/variables/#the-hierarchy-resolution-order","title":"The Hierarchy (Resolution Order)","text":"<p>Zetten resolves variables using a \"Strict Tier\" system. If a variable is defined in multiple places, the higher tier always wins.</p>"},{"location":"guides/variables/#tier-1-cli-overrides-highest","title":"Tier 1: CLI Overrides (Highest):","text":"<p>Values passed directly via the -k (or --key) flag. This is used for \"one-off\" changes.</p> <pre><code>zetten run build -k DEST=build_output\n</code></pre>"},{"location":"guides/variables/#tier-2-config-file","title":"Tier 2: Config File","text":"<p>Values defined globally in your configuration file under the vars table.</p> <pre><code>[tool.zetten.vars]\nDEST = \"local_cache\"\n</code></pre>"},{"location":"guides/variables/#tier-3-environment-variables-lowest","title":"Tier 3: Environment Variables (Lowest)","text":"<p>Standard system environment variables (e.g., $USER, $PATH, or variables exported in your shell).</p> <pre><code>export DEST=system_dist\nzetten run build\n</code></pre>"},{"location":"guides/variables/#global-variables-vars","title":"Global Variables (vars)","text":"<p>Zetten allows you to define a global vars table. These variables act as \"Defaults\"\u2014they will be injected into any task's cmd that references them, unless you override them via the CLI.</p>"},{"location":"guides/variables/#example-pyprojecttoml","title":"Example: <code>pyproject.toml</code>","text":"<p>Place your global variables under the <code>[tool.zetten.vars]</code> section.</p> <pre><code>[tool.zetten.vars]\nBUILD_DIR = \"dist\"\nPYTHON_BIN = \"python3\"\nLOG_LEVEL = \"info\"\n\n[tool.zetten.tasks.build]\n# Uses the global BUILD_DIR and PYTHON_BIN defined above\ncmd = \"${PYTHON_BIN} -m build --outdir ${BUILD_DIR}\"\ninputs = [\"src/\"]\n</code></pre>"},{"location":"guides/variables/#example-zettentoml","title":"Example: <code>zetten.toml</code>","text":"<p>If using a standalone file, use the [vars] header.</p> <pre><code>[vars]\nBUILD_DIR = \"dist\"\n\n[tasks.build]\ncmd = \"mkdir -p ${BUILD_DIR} &amp;&amp; tar -cvf ${BUILD_DIR}/pkg.tar src/\"\ninputs = [\"src/\"]\n</code></pre>"},{"location":"reference/commands/","title":"CLI Commands","text":""},{"location":"reference/commands/#init","title":"<code>init</code>","text":"<p>Interactive project setup and template generation.</p> <pre><code>zetten init\n</code></pre>"},{"location":"reference/commands/#run","title":"<code>run</code>","text":"<p>Execute tasks.</p> <pre><code>zetten run &lt;task_name&gt;\n</code></pre>"},{"location":"reference/commands/#watch","title":"<code>watch</code>","text":"<p>Re-run tasks when inputs change.</p> <pre><code>zetten watch &lt;task_name&gt;\n</code></pre>"},{"location":"reference/commands/#graph","title":"<code>graph</code>","text":"<p>Inspect the task dependency graph.</p> <pre><code>zetten graph\n</code></pre>"},{"location":"reference/commands/#doctor","title":"<code>doctor</code>","text":"<p>Diagnose configuration and environment issues.</p> <pre><code>zetten doctor\n</code></pre>"},{"location":"reference/commands/#completions","title":"<code>completions</code>","text":"<p>Generate shell completion scripts</p> <pre><code>zetten completion &lt;SHELL&gt;\n</code></pre>"}]}